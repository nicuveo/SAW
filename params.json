{"name":"Saw","tagline":"Sqlite3 API Wrapper","body":"*SAW* (Sqlite3 API Wrapper)\r\n===========================\r\n\r\n> My heart is full of `saw::Row`.  \r\n-- *Sad anonymous*\r\n\r\n> A **Z** that stands for `saw::Row`!  \r\n-- *Illiterate anonymous*\r\n\r\n\r\nYet another wrapper\r\n-------------------\r\n\r\nFaced with the need to write some code using sqlite3's C API, I've procrastinated the real task at hand by writing a standalone library wrapping it.\r\n\r\nThe goal of this small library is *NOT* to hide sqlite3's API; if it aimed to do so, it would be far more complicated than it already is. Its goal is simply to facilitate some common sqlite3 tasks, such as managing database connections and statements. All wrapped structures such as `Database` and `Statement` provide access to the raw data that lies beneath.\r\n\r\nHere's a short example of the clarity it brings to the code.\r\n\r\n\r\n### C API\r\n\r\n``` c++\r\nint run(const char* name, int score_min)\r\n{\r\n  sqlite3* db = 0;\r\n  sqlite3_stmt* stmt = 0;\r\n\r\n  int res = sqlite3_open(\"test.db\", &db);\r\n\r\n  if (res != SQLITE_OK)\r\n    return res;\r\n\r\n  res = sqlite3_prepare_v2(db, \"create table if not exists results (name text, score int)\", &stmt, 0);\r\n\r\n  if (res != SQLITE_OK)\r\n    return res;\r\n\r\n  res = sqlite3_step(stmt);\r\n\r\n  if (res != SQLITE_DONE)\r\n    return 1;\r\n\r\n  sqlite3_finalize(stmt);\r\n\r\n  res = sqlite3_prepare_v2(db, \"select score from results where name = ? and score >= ?\", &stmt, 0);\r\n\r\n  if (res != SQLITE_OK)\r\n    return res;\r\n\r\n  res = sqlite3_bind_text(stmt, 1, name, 0, SQLITE_TRANSIENT);\r\n\r\n  if (res != SQLITE_OK)\r\n    return res;\r\n\r\n  res = sqlite3_bind_int(stmt, 2, score_min);\r\n\r\n  if (res != SQLITE_OK)\r\n    return res;\r\n\r\n  res = sqlite3_step(stmt);\r\n\r\n  while (res != SQLITE_DONE)\r\n  {\r\n    if (res != SQLITE_ROW)\r\n      return res;\r\n\r\n    std::cout << \"score: \" << sqlite3_column_int(stmt, 0) << std::endl;\r\n  }\r\n\r\n  sqlite3_finalize(stmt);\r\n  sqlite3_close(db);\r\n\r\n  return 0;\r\n}\r\n```\r\n\r\n\r\n### *SAW*\r\n\r\n``` c++\r\nvoid run(const char* name, int score_min)\r\n{\r\n  try\r\n  {\r\n    saw::Database db(\"test.db\");\r\n    saw::Statement stmt;\r\n\r\n    db.exec(\"create table if not exists results (name text, score int)\");\r\n\r\n    stmt = db.make(\"select score from results where name = ? and score >= ?\");\r\n    stmt[1] = name;\r\n    stmt[2] = score_min;\r\n\r\n    BOOST_FOREACH (const saw::Row& row, stmt.result())\r\n      std::cout << \"score: \" << row[0].as_integer() << std::endl;\r\n  }\r\n  catch (const saw::Exception& e)\r\n  {\r\n    std::cerr << \"error: \" << e.what() << std::endl;\r\n  }\r\n}\r\n```\r\n\r\n\r\nInstallation\r\n------------\r\n\r\n``` bash\r\n./configure\r\nmake\r\nmake doc     # generates doxygen documentation\r\nmake check   # runs tests and generates code coverage report using lcov and cppcheck\r\nmake install # installs to /usr/local\r\n```\r\n\r\n\r\n\r\nInternal plumbing\r\n-----------------\r\n\r\nInside, *SAW* uses lots of `boost` code. For instance, database and statement handlers are shared using reference counting shared pointers. Values are implemented using `boost::variant` and iterators use `boost::iterator_facade`.\r\n\r\nThe code has been mostly tested and is currently at >90% of code coverage as reported by *lcov*.\r\n\r\nIf, somehow, you end up using it, please let me know what you think!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}